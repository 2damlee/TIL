# lambda

>  generic / lambda/  익명 클래스 등은 문법의 간편화를 가져와준다. 
>
>  중첩클래스, 중첩인터페이스 등을 간단하게 표현해주는 식이 람다식
>
>  보통 cpu나 메모리양이 작은 앱개발 같은 곳에서 사용된다. 사용되고 금방 사라지는 식이기 때문. 웹서버에서는 잘 보지 않는 부분일 수 있음. 

* 람다 - 매개변수 선언 실행 문장 블록, 익명의 구현객체들을 더 간단하게 만들어주는 식 

  * 즉, 람다는 일종의 무명의 메소드이다. 메소드는 클래스 틀이 없을 수 있다. 

  ````java
  class A{
    int add(int x, int y){
      return x + y;
    }
  }
  
  // lambda  
  (x,y)->{return x + y;}
  (선언에 필요한 매개변수 두 개) -> {매개변수 두 개로 하는 일을 정의}
  ````

* 람다식 기본 문법 1) 정의

  * **람다식에서의 약속 : 인터페이스 내부에 하나의 메소드만 만든다** 

````java
(타입 매개변수) -> {실행 문장 블록}
(변수명 , , ,) -> {실행 문장 블록} // 타입 생략 가능 
() -> {실행 문장 블록} // 빈 변수명도 가능
변수명 -> {실행 문장 블록} // 매개변수가 하나라면, ()생략 가능
변수명 -> 실행 문장; // 매개변수도 하나, 실행 문장도 한 줄이라면 (), {} 생략 가능

````

* 람다식 기본 문법 2) 실행

  * 타겟 타입과 함수적 인터페이스 

  ````java
  class A{void ma(){}}
  abstract class B{void ma(){}  abstract void mb();}
  interface C class B{void ma(){}  abstract void mb();}
  
  //익명객체 만들기 1)
  new C(){
    public void ma(){ ... }
    public void mb(){ ... }
  }.ma();
  
  //익명객체 만들기 2) 
  C c1 = new C(){
    public void ma(){ ... }
    public void mb(){ ... }
  };
  
  c1.ma();
  c1.mb();
  ````

  * 람다식 예시 

  ````java
  // 한 개의 정의 약속 
  @FunctionalInterface // 컴파일러에게 해당 인터페이스에 메소드가 하나만 있는가를 검사
  interface I {
    void m1(int x);
  }
  
  //익명의 객체
  new I(){
    void m1(){}
  }.m1();
  
  //람다식
  //만들되 람다를 무슨 타입으로 쓸 지 결정해줘야함. 왼쪽에 인터페이스 타입을 줘야 함.
  I i1 = (x) -> {}
  i1.m1(10);
  ````

  