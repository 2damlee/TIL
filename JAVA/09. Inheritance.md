# 상속

* 상속은 물려준다는 개념이다. 상속은 공통된 특성의 무언가를 객체들이 상속받는 개념이다. 학생, 회사원, 교수는 모두 인간이다. (학생, 회사원, 교수 is a 인간) 이에 따라 학생, 회사원, 교수는 인간을 상속받을 수 있다.

* 상속은 이미 개발된 클래스를 재사용해서 새로운 클래스를 만들어주기 때문에 코드의 중복을 줄여줄 수 있다. 

**객체생성 : has- a 관계**

**상속: is - a 관계**

````java
class 자식클래스 extends 부모클래스 {
  //필드
  //생성자
  //메소드
}
````

- 상위클래스의 private은 변수의 사용이 불가능하다. 

- 상위, 하위 클래스의 동일명의 변수가 존재할 경우, 하위 클래스의 변수를 우선적으로 인식한다. (예외 우선)

- this가 자기 자신의 객체를 가르킨다면, super는 상위 클래스의 객체를 가르킨다.

  `````java
  super.멤버변수명 //상위 클래스의 멤버변수와 하위 클래스의 멤버변수 이름이 같을 때 구분
  super.메소드명() // 상위 메소드와 하위 메소드의 이름이 같을 때 구분
    
  super(); // 상위 기본 생성자 호출. 호출하지 않아도 자동 정의
  super(매개변수); //상위 매개변수 정의 생성자 호출, 호출시 상위 기본 생성자는 사라진다. 
  `````

  ````java
  package day4;
  
  class P { 
  	int i;
   	P(String s){
  		//super();/Object () 생성자 호출  
  		i = 10;
  		System.out.println("A생성자 호출");
  	}
  	
  }
  
  class B extends P {
  	int j;
      B(){
      	super("aaa");
      	//super(); //A() 생성자 호출  
      	j=100;
      	System.out.println("B생성자 호출");
      }
  	
  }
  public class SuperTest {
  
  	public static void main(String[] args) {
  	   
       B b1 = new B(); //Object, A, B 객체 모두 만드는 것 
       System.out.println(b1.i);
       System.out.println(b1.j);		
  		
  	}
  
  }
  ````


상속의 규칙: 

* 다중 상속은 금지된다
  * 상위 클래스에 구현된 객체가 있고, 다중상속받을 경우 상위 클래스의 객체를 호출할 때 충돌할 가능성이 있기 때문에 자바는 다중상속을 막아놓는다.



### overriding

상속된 일부 메소드를 다시 수정해서 사용할 경우, overriding을 사용한다. 

​	**규칙**

* 부모의 메소드와 동일한 리턴타입, 메소드 이름, 매개변수 리스트를 가져야한다. 
* 접근 제한을 더 강하게 오버라이딩 할 수 없다.
* 새로운 예외를 throws할 수 없다. 







## 타입 변환과 다형성

다형성은 같은 타입이지만 실행 결과가 다양한 객체를 이용할 수 있는 성질을 의미한다. overloading이나 overriding의 경우가 다형성의 예시이다. 그리고 자바는, 다형성을 위해 모든 자식 클래스를 부모 클래스로의 타입 변환을 허용한다. 

객체의 타입을 통일할 경우, 객체를 통일해서 여러 객체를 다루고 싶을때 형변환을 사용한다. 



##### 자동 타입 변환

````java
부모클래스 변수 = 자식클래스타입;
````

이 경우, 변수는 자식 객체를 참조하지만 변수로 접근 가능한 멤버는 부모 클래스 멤버로 한정된다.

예외) 만약 자식 클래스에서 부모 클래스를 오버라이딩했다면, 오버라이딩이 실행된다. 예외 우선의 법칙. 



##### 강제 타입 변환

````java
자식클래스 변수 = (자식클래스) 부모클래스타입;
````

자식타입이 부모타입으로 자동 변환한 후, 다시 자식 타입으로 변환할 때 강제 타입 변환을 사용할 수 있다. 즉, 자동 타입 변환된 자식 타입을 다시 돌릴 때만 사용하는 것이다. 





### 객체타입확인 (instance of)

```java
boolean result = 좌항(객체) instanceof 우항(타입)
  //좌항의 객체가 우항의 instancedlaus true, 아니면 false
```

메소드 내에서 강제 타입 변환이 필요한 경우, 반드시 매개값이 어떤 객체인지 insanceof 연산자로 확인해야 한다.

````java
public void method(Parent parent){
  if(parent instanceof Child) { // 자동형변환이 되었다면, parent는 상위클래스를 참조하고 있더라도 상위클래스를 가르키고 있는 것이 아닌 Child를 참조, Child의 상위 클래스를 참조하고 있기 때문에 궁극적으로 parent는 Child 타입의 객체가 된다. 
    Child child = (Child)parent;
  }
}
````

